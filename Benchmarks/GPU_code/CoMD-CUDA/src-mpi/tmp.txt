gpu_kernels.cu:          LJ_Force_thread_atom<<<grid, block>>>(*sim, (*sim).a_list);
gpu_kernels.cu:          LJ_Force_thread_atom_interpolation<<<grid, block>>>(*sim, (*sim).a_list);
gpu_kernels.cu:          LJ_Force_cta_cell<<<grid, block>>>(*sim, cells_list, sim->lj_pot.cutoff*sim->lj_pot.cutoff, s6);
gpu_kernels.cu:              LJ_Force_cta_cell_pairlist<true, PAIRLIST_ATOMS_PER_INT><<<grid, block>>>(*sim, cells_list, sim->lj_pot.cutoff*sim->lj_pot.cutoff, s6, plcutoff);
gpu_kernels.cu:              LJ_Force_cta_cell_pairlist<false, PAIRLIST_ATOMS_PER_INT><<<grid, block>>>(*sim, cells_list, sim->lj_pot.cutoff*sim->lj_pot.cutoff, s6, plcutoff);
gpu_kernels.cu:            EAM_Force_thread_atom<step, true><<<grid, block, 0, stream>>>(sim, atoms_list);
gpu_kernels.cu:            EAM_Force_warp_atom<step, true><<<grid, block, 0, stream>>>(sim, atoms_list);
gpu_kernels.cu:            EAM_Force_cta_cell<step, true><<<grid, block, smem, stream>>>(sim, cells_list);
gpu_kernels.cu:            EAM_Force_thread_atom_NL<step, true><<<grid, block, 0, stream>>>(sim, atoms_list);
gpu_kernels.cu:            EAM_Force_warp_atom_NL<step, KERNEL_PACKSIZE, MAXNEIGHBORLISTSIZE, true><<<grid, block, 0, stream>>>(sim, atoms_list, sim.eam_pot.cutoff * sim.eam_pot.cutoff);
gpu_kernels.cu:            EAM_Force_thread_atom<step, false><<<grid, block, 0, stream>>>(sim, atoms_list);
gpu_kernels.cu:            EAM_Force_warp_atom<step, false><<<grid, block, 0, stream>>>(sim, atoms_list);
gpu_kernels.cu:            EAM_Force_cta_cell<step, false><<<grid, block, smem, stream>>>(sim, cells_list);
gpu_kernels.cu:            EAM_Force_thread_atom_NL<step, false><<<grid, block, 0, stream>>>(sim, atoms_list);
gpu_kernels.cu:            EAM_Force_warp_atom_NL<step, KERNEL_PACKSIZE, MAXNEIGHBORLISTSIZE, false><<<grid, block, 0, stream>>>(sim, atoms_list, sim.eam_pot.cutoff * sim.eam_pot.cutoff);
gpu_kernels.cu:    EAM_Force_thread_atom2<<<grid, block, 0, stream>>>(sim, atoms_list);
gpu_kernels.cu:    EAM_Force_cta_cell2<<<grid, block, 0, stream>>>(sim, cells_list);
gpu_kernels.cu:  UpdateNeighborNumAtoms<<<grid, block, 0, stream>>>(sim, nCells, cellList, temp);
gpu_kernels.cu:  UpdateNeighborAtomIndices<<<grid, block, 0, stream>>>(sim, nCells, cellList, temp);
gpu_kernels.cu:  UpdateNeighborNumAtoms<<<grid, block>>>(sim, sim.boxes.nLocalBoxes, NULL, temp);
gpu_kernels.cu:  UpdateNeighborAtomIndices<<<grid, block>>>(sim, sim.boxes.nLocalBoxes, NULL, temp);
gpu_kernels.cu:  AdvanceVelocity<<<grid, block>>>(sim, dt);
gpu_kernels.cu:  AdvancePosition<<<grid, block>>>(*sim, dt);
gpu_kernels.cu:  fill<<<grid, block, 0, stream>>>(d_cellOffsets, nCells, cellList, num_atoms);
gpu_kernels.cu:  fill<<<grid, block, 0, stream>>>(natoms_buf, nCells, num_atoms);
gpu_kernels.cu:  UpdateAtomList<<<grid, block>>>(s->gpu, s->gpu.a_list, nCells, cell_offsets1);
gpu_kernels.cu:  UpdateBoundaryList<<<grid, block>>>(s->gpu, s->gpu.b_list, s->n_boundary_cells, cell_offsets1, s->boundary_cells);
gpu_kernels.cu:  UpdateBoundaryList<<<grid, block>>>(s->gpu, s->gpu.i_list, n_interior_cells, cell_offsets2, s->interior_cells);
gpu_kernels.cu:      UpdateLinkCells<true><<<grid, block>>>(sim->gpu, sim->gpu.boxes, flags);
gpu_kernels.cu:      UpdateLinkCells<false><<<grid, block>>>(sim->gpu, sim->gpu.boxes, flags);
gpu_kernels.cu:      CompactAtoms<true><<<grid, block>>>(sim->gpu, sim->boxes->nLocalBoxes, flags);
gpu_kernels.cu:      CompactAtoms<false><<<grid, block>>>(sim->gpu, sim->boxes->nLocalBoxes, flags);
gpu_kernels.cu:    LoadAtomsBufferPacked<<<grid, block,0,stream>>>(msg_d, d_cellList, sim_gpu, d_cellOffsets, shift[0], shift[1], shift[2]);
gpu_kernels.cu:  UpdateCompactIndices<<<grid, block, 0, stream>>>(natoms_buf, nCells, sim->gpu);
gpu_kernels.cu:  UnloadAtomsBufferPacked<<<grid, block, 0, stream>>>(r, p, type, gid, nBuf, sim->gpu.atoms, d_iOffset);
gpu_kernels.cu:  LoadForceBuffer<<<grid, block, 0, stream>>>((ForceMsg*)gpu_buf, nCells, cellList, s->gpu, natoms_buf);
gpu_kernels.cu:  UnloadForceBuffer<<<grid, block, 0, stream>>>((ForceMsg*)gpu_buf, nCells, cellList, s->gpu, natoms_buf);
gpu_kernels.cu:  SetLinearIndices<<<grid, block, 0, stream>>>(s->gpu, s->n_boundary1_cells, s->boundary1_cells_d, new_indices);
gpu_kernels.cu:  SetLinearIndices<<<grid, block, 0, stream>>>(s->gpu, s->boxes->nLocalBoxes, s->boxes->nTotalBoxes, new_indices);
gpu_kernels.cu:  SortAtomsByGlobalId<<<grid2, block2, 0, stream>>>(s->gpu, s->boxes->nLocalBoxes, s->boxes->nTotalBoxes, s->boundary1_cells_d, s->n_boundary1_cells, new_indices, s->tmp_sort);
gpu_kernels.cu:  ShuffleAtomsData<<<grid3, block3, 0, stream>>>(s->gpu, s->boxes->nLocalBoxes, s->boxes->nTotalBoxes, s->boundary1_cells_d, s->n_boundary1_cells, new_indices);
gpu_kernels.cu:  ReduceEnergy<<<grid, block>>>(flat->gpu, &e_gpu[0], &e_gpu[1]);
gpu_kernels.cu:    emptyNeighborListGpuKernel<<<grid,block>>>(*sim, boundaryFlag);
gpu_kernels.cu:        updatePairlistRequiredKernel<<<grid, block>>>(*sim, d_updatePairlistRequired);
gpu_kernels.cu:                updateNeighborListRequiredKernel<<<grid, block>>>(*sim, d_updateNeighborListRequired);
gpu_kernels.cu:                 buildNeighborListKernel_thread<BOUNDARY><<<grid, block>>>(*sim);
gpu_kernels.cu:                 buildNeighborListKernel_thread<INTERIOR><<<grid, block >>>(*sim);
gpu_kernels.cu:                 buildNeighborListKernel_thread<BOTH><<<grid, block>>>(*sim);
gpu_kernels.cu:                 buildNeighborListKernel_warp<MAXNEIGHBORLISTSIZE, packSize, logPackSize, 1, BOUNDARY><<<grid, block>>>(*sim, rCut2);
gpu_kernels.cu:                 buildNeighborListKernel_warp<MAXNEIGHBORLISTSIZE, packSize, logPackSize, 1, INTERIOR><<<grid, block>>>(*sim, rCut2);
gpu_kernels.cu:                 buildNeighborListKernel_warp<MAXNEIGHBORLISTSIZE, packSize, logPackSize, 1, BOTH><<<grid, block>>>(*sim, rCut2);
gpu_kernels.cu:                   buildNeighborListKernel_warp<MAXNEIGHBORLISTSIZE, packSize, logPackSize, memoryPackSize, BOUNDARY><<<grid, block>>>(*sim, rCut2);
gpu_kernels.cu:                   buildNeighborListKernel_warp<MAXNEIGHBORLISTSIZE, packSize, logPackSize, memoryPackSize, INTERIOR><<<grid, block>>>(*sim, rCut2);
gpu_kernels.cu:                   buildNeighborListKernel_warp<MAXNEIGHBORLISTSIZE, packSize, logPackSize, memoryPackSize, BOTH><<<grid, block>>>(*sim, rCut2);
gpu_redistribute.h:     computeBoxIds<<<grid, block, 0, stream>>>(sim->gpu.boxes, r, d_boxId, nBuf); //fill d_boxId with iBox for each atom
gpu_redistribute.h:        computeOffsetsUpdateReq<1><<<grid, block, 0, stream>>>(d_iOffset, nBuf, sim->gpu.boxes.nAtoms, d_boxId, sim->gpu);
gpu_redistribute.h:        computeOffsetsUpdateReq<0><<<grid, block, 0, stream>>>(d_iOffset, nBuf, sim->gpu.boxes.nAtoms, d_boxId, sim->gpu);
gpu_redistribute.h:     updateNAtoms<<<grid, block, 0, stream>>>(sim->gpu.boxes.nAtoms,d_boxId, nBuf);
gpu_redistribute.h:     computeOffsetsNoUpdateReq<<<grid, block, 0, stream>>>(d_iOffset, nBuf, sim->gpu.boxes.nAtoms, sim->gpu.d_hashTable);
gpu_utility.c://  unpackHaloCells<<<grid, block>>>(d_cellOffset, d_compactAtoms, sim->gpu); //TODO implement this function
